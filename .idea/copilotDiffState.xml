<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/misi_budaya/data/repository/QuizRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/misi_budaya/data/repository/QuizRepository.kt" />
              <option name="originalContent" value="package com.example.misi_budaya.data.repository&#10;&#10;import com.example.misi_budaya.data.model.Paket&#10;import com.example.misi_budaya.data.model.Pilihan&#10;import com.example.misi_budaya.data.model.Question&#10;import com.example.misi_budaya.data.model.QuestionDao&#10;import com.example.misi_budaya.data.model.QuizPackage&#10;import com.example.misi_budaya.data.model.QuizPackageDao&#10;import com.example.misi_budaya.data.model.Soal&#10;import com.example.misi_budaya.data.model.UserProfile&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.Query&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.tasks.await&#10;&#10;class QuizRepository(private val quizPackageDao: QuizPackageDao, private val questionDao: QuestionDao) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;    private val paketCollection = db.collection(&quot;Paket&quot;)&#10;    private val soalCollection = db.collection(&quot;Soal&quot;)&#10;    private val usersCollection = db.collection(&quot;Users&quot;)&#10;&#10;    // --- Leaderboard --- &#10;    suspend fun getLeaderboardData(): List&lt;UserProfile&gt; {&#10;        return try {&#10;            usersCollection&#10;                .orderBy(&quot;totalScore&quot;, Query.Direction.DESCENDING)&#10;                .limit(100) // Limit to top 100 to avoid pulling too much data&#10;                .get()&#10;                .await()&#10;                .toObjects(UserProfile::class.java)&#10;        } catch (e: Exception) {&#10;            // Return an empty list or throw the exception to be handled by the presenter&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    // --- Quiz Packages ---&#10;    fun getPaketList(): Flow&lt;List&lt;QuizPackage&gt;&gt; {&#10;        return quizPackageDao.getAllQuizPackages()&#10;    }&#10;&#10;    suspend fun refreshPaketList() {&#10;        try {&#10;            android.util.Log.d(&quot;QuizRepository&quot;, &quot;Starting refreshPaketList from Firebase&quot;)&#10;            val result = paketCollection.get().await()&#10;            android.util.Log.d(&quot;QuizRepository&quot;, &quot;Firebase returned ${result.documents.size} documents&quot;)&#10;            &#10;            // Log setiap dokumen untuk debugging&#10;            result.documents.forEach { doc -&gt;&#10;                android.util.Log.d(&quot;QuizRepository&quot;, &quot;Document ID: ${doc.id}, Data: ${doc.data}&quot;)&#10;            }&#10;            &#10;            val firebasePaketList = result.documents.mapNotNull { document -&gt;&#10;                val paket = document.toObject(Paket::class.java)&#10;                if (paket != null) {&#10;                    paket.id = document.id&#10;                    android.util.Log.d(&quot;QuizRepository&quot;, &quot;Parsed Paket: namaPaket=${paket.namaPaket}, isSecret=${paket.isSecret}&quot;)&#10;                } else {&#10;                    android.util.Log.w(&quot;QuizRepository&quot;, &quot;Failed to parse document ${document.id}&quot;)&#10;                }&#10;                paket&#10;            }&#10;            android.util.Log.d(&quot;QuizRepository&quot;, &quot;Parsed ${firebasePaketList.size} Paket objects&quot;)&#10;&#10;            val packagesToUpsert = mutableListOf&lt;QuizPackage&gt;()&#10;&#10;            for (paket in firebasePaketList.filter { !it.isSecret }) {&#10;                val existingPackage = quizPackageDao.getQuizPackageByName(paket.namaPaket)&#10;&#10;                val mergedPackage = QuizPackage(&#10;                    name = paket.namaPaket,&#10;                    description = &quot;&quot;,&#10;                    score = existingPackage?.score ?: 0,&#10;                    isCompleted = existingPackage?.isCompleted ?: false&#10;                )&#10;                packagesToUpsert.add(mergedPackage)&#10;                android.util.Log.d(&quot;QuizRepository&quot;, &quot;Added package to upsert: ${paket.namaPaket}&quot;)&#10;            }&#10;&#10;            android.util.Log.d(&quot;QuizRepository&quot;, &quot;Inserting ${packagesToUpsert.size} packages to Room&quot;)&#10;            quizPackageDao.insertAll(*packagesToUpsert.toTypedArray())&#10;            android.util.Log.d(&quot;QuizRepository&quot;, &quot;Successfully inserted packages to Room&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;QuizRepository&quot;, &quot;Error in refreshPaketList&quot;, e)&#10;            throw e&#10;        }&#10;    }&#10;&#10;    // --- Questions ---&#10;    suspend fun getSoalList(paketId: String, forceRefresh: Boolean = false): List&lt;Question&gt; {&#10;        var localQuestions = questionDao.getQuestionsForQuiz(paketId)&#10;        if (localQuestions.isNotEmpty() &amp;&amp; !forceRefresh) {&#10;            return localQuestions&#10;        }&#10;&#10;        // If local is empty or force refresh, try fetching from Firebase&#10;        val firebaseSoalList = soalCollection.whereEqualTo(&quot;paketId&quot;, paketId).get().await()&#10;            .documents.mapNotNull { document -&gt;&#10;                document.toObject(Soal::class.java)?.apply { id = document.id }&#10;            }&#10;&#10;        val questionsToCache = firebaseSoalList.map { soal -&gt;&#10;            Question(&#10;                id = soal.id,&#10;                quizPackageName = paketId,&#10;                questionText = soal.soal,&#10;                questionImageUrl = soal.gambarSoal,&#10;                choices = soal.pilihan.map { Pilihan(it.id, it.teks, it.gambar) },&#10;                correctAnswerId = soal.jawabanBenar&#10;            )&#10;        }&#10;&#10;        if (questionsToCache.isNotEmpty()) {&#10;            questionDao.insertAll(questionsToCache)&#10;        }&#10;&#10;        return questionsToCache&#10;    }&#10;&#10;    // --- Score Updates ---&#10;    suspend fun updateQuizScore(quizName: String, newScore: Int) {&#10;        // Update Local Score (Room)&#10;        val existingPackage = quizPackageDao.getQuizPackageByName(quizName)&#10;        if (existingPackage != null) {&#10;            if (newScore &gt; existingPackage.score) {&#10;                val updatedPackage = existingPackage.copy(score = newScore, isCompleted = true)&#10;                quizPackageDao.updateQuizPackage(updatedPackage)&#10;            } else {&#10;                if (!existingPackage.isCompleted) {&#10;                    val updatedPackage = existingPackage.copy(isCompleted = true)&#10;                    quizPackageDao.updateQuizPackage(updatedPackage)&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Update Remote Score (Firestore)&#10;        updateUserScoresInFirestore(quizName, newScore)&#10;    }&#10;&#10;    private suspend fun updateUserScoresInFirestore(quizName: String, newScore: Int) {&#10;        val currentUser = auth.currentUser ?: return&#10;        val userId = currentUser.uid&#10;        val userDocRef = usersCollection.document(userId)&#10;&#10;        try {&#10;            db.runTransaction {&#10;                transaction -&gt;&#10;                val snapshot = transaction.get(userDocRef)&#10;&#10;                if (snapshot.exists()) {&#10;                    // Document exists, so UPDATE it&#10;                    val raw = snapshot.get(&quot;quizScores&quot;) as? Map&lt;*, *&gt; ?: emptyMap&lt;Any, Any?&gt;()&#10;                    val oldQuizScores: Map&lt;String, Long&gt; = raw.entries.associate { (k, v) -&gt;&#10;                        val key = k.toString()&#10;                        val value = when (v) {&#10;                            is Number -&gt; v.toLong()&#10;                            is String -&gt; v.toLongOrNull() ?: 0L&#10;                            else -&gt; 0L&#10;                        }&#10;                        key to value&#10;                    }&#10;                    val oldTotalScore = snapshot.getLong(&quot;totalScore&quot;) ?: 0L&#10;                    val oldScoreForThisQuiz = oldQuizScores[quizName] ?: 0L&#10;&#10;                    if (newScore &gt; oldScoreForThisQuiz) {&#10;                        val scoreDifference = newScore - oldScoreForThisQuiz&#10;                        val newTotalScore = oldTotalScore + scoreDifference&#10;                        transaction.update(userDocRef, &quot;quizScores.$quizName&quot;, newScore.toLong())&#10;                        transaction.update(userDocRef, &quot;totalScore&quot;, newTotalScore)&#10;                    }&#10;                } else {&#10;                    // Document does not exist, so CREATE it&#10;                    val newUserProfile = UserProfile(&#10;                        uid = userId,&#10;                        email = currentUser.email ?: &quot;&quot;,&#10;                        username = currentUser.displayName ?: &quot;&quot;,&#10;                        quizScores = mapOf(quizName to newScore.toLong()),&#10;                        totalScore = newScore.toLong(),&#10;                        unlockedQuizzes = emptyMap() // Default for new user&#10;                    )&#10;                    transaction.set(userDocRef, newUserProfile)&#10;                }&#10;                null&#10;            }.await()&#10;        } catch (e: Exception) {&#10;            // For now, we let it fail silently so it doesn't crash the app&#10;            android.util.Log.e(&quot;QuizRepository&quot;, &quot;updateUserScoresInFirestore failed&quot;, e)&#10;        }&#10;    }&#10;&#10;    // --- New: User score sync utilities ---&#10;    /**&#10;     * Fetch quizScores map for a user from Firestore (returns empty map on failure)&#10;     */&#10;    suspend fun getUserQuizScores(uid: String): Map&lt;String, Long&gt; {&#10;        return try {&#10;            val doc = usersCollection.document(uid).get().await()&#10;            if (doc.exists()) {&#10;                val raw = doc.get(&quot;quizScores&quot;) as? Map&lt;*, *&gt; ?: emptyMap&lt;Any, Any?&gt;()&#10;                raw.entries.associate { (k, v) -&gt;&#10;                    val key = k.toString()&#10;                    val value = when (v) {&#10;                        is Number -&gt; v.toLong()&#10;                        is String -&gt; v.toLongOrNull() ?: 0L&#10;                        else -&gt; 0L&#10;                    }&#10;                    key to value&#10;                }&#10;            } else {&#10;                emptyMap()&#10;            }&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;QuizRepository&quot;, &quot;Failed to fetch user quizScores&quot;, e)&#10;            emptyMap()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clear all local quiz package scores in Room (used when offline session not associated with account)&#10;     */&#10;    suspend fun clearLocalScores() {&#10;        try {&#10;            quizPackageDao.clearQuizPackages()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;QuizRepository&quot;, &quot;Failed to clear local scores&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sync scores between Firestore and Room for given user uid.&#10;     * Strategy: for each quiz in Firestore or Room, keep the higher score in both places.&#10;     */&#10;    suspend fun syncScoresForUser(uid: String) {&#10;        try {&#10;            val remoteScores = getUserQuizScores(uid).toMutableMap()&#10;&#10;            // pull all local packages&#10;            val localPackages = quizPackageDao.getAllQuizPackagesOnce()&#10;&#10;            // Merge keys&#10;            val allKeys = (remoteScores.keys + localPackages.map { it.name }).toSet()&#10;&#10;            var anyRemoteUpdated = false&#10;             for (quizName in allKeys) {&#10;                 val localPkg = localPackages.find { it.name == quizName }&#10;                 val localScore = localPkg?.score ?: 0&#10;                 val remoteScore = (remoteScores[quizName] ?: 0L).toInt()&#10;&#10;                 val winnerScore = maxOf(localScore, remoteScore)&#10;&#10;                 // update local&#10;                 if (localPkg != null) {&#10;                     val updatedPkg = localPkg.copy(score = winnerScore, isCompleted = winnerScore &gt; 0)&#10;                     quizPackageDao.updateQuizPackage(updatedPkg)&#10;                 } else {&#10;                     // insert new package to local&#10;                     val newPkg = QuizPackage(name = quizName, description = &quot;&quot;, score = winnerScore, isCompleted = winnerScore &gt; 0)&#10;                     quizPackageDao.insertAll(newPkg)&#10;                 }&#10;&#10;                 // update remote if needed&#10;                 val remoteScoreLong = remoteScores[quizName] ?: 0L&#10;                 if (winnerScore.toLong() &gt; remoteScoreLong) {&#10;                     // write to firestore user document&#10;                     try {&#10;                         val userRef = usersCollection.document(uid)&#10;                         userRef.update(&quot;quizScores.$quizName&quot;, winnerScore.toLong()).await()&#10;                         // adjust totalScore as naive sum difference (for safety, we can recalc totalScore server-side)&#10;                         val doc = userRef.get().await()&#10;                         val oldTotal = doc.getLong(&quot;totalScore&quot;) ?: 0L&#10;                         val oldForQuiz = remoteScoreLong&#10;                         val newTotal = oldTotal + (winnerScore.toLong() - oldForQuiz)&#10;                         userRef.update(&quot;totalScore&quot;, newTotal).await()&#10;                         // notify leaderboard listeners that remote data changed&#10;                         try { com.example.misi_budaya.util.AppEvents.emitLeaderboardRefresh() } catch (_: Exception) {}&#10;                        anyRemoteUpdated = true&#10;                     } catch (e: Exception) {&#10;                         android.util.Log.e(&quot;QuizRepository&quot;, &quot;Failed to update remote score for $quizName&quot;, e)&#10;                     }&#10;                 }&#10;             }&#10;&#10;            // If any remote updates occurred, emit a final refresh event to be safe&#10;            if (anyRemoteUpdated) {&#10;                try { com.example.misi_budaya.util.AppEvents.emitLeaderboardRefresh() } catch (_: Exception) {}&#10;            }&#10;         } catch (e: Exception) {&#10;             android.util.Log.e(&quot;QuizRepository&quot;, &quot;Error in syncScoresForUser&quot;, e)&#10;         }&#10;     }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.misi_budaya.data.repository&#10;&#10;import com.example.misi_budaya.data.model.Paket&#10;import com.example.misi_budaya.data.model.Pilihan&#10;import com.example.misi_budaya.data.model.Question&#10;import com.example.misi_budaya.data.model.QuestionDao&#10;import com.example.misi_budaya.data.model.QuizPackage&#10;import com.example.misi_budaya.data.model.QuizPackageDao&#10;import com.example.misi_budaya.data.model.Soal&#10;import com.example.misi_budaya.data.model.UserProfile&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.Query&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.tasks.await&#10;&#10;class QuizRepository(private val quizPackageDao: QuizPackageDao, private val questionDao: QuestionDao) {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;    private val paketCollection = db.collection(&quot;Paket&quot;)&#10;    private val soalCollection = db.collection(&quot;Soal&quot;)&#10;    private val usersCollection = db.collection(&quot;Users&quot;)&#10;&#10;    // --- Leaderboard --- &#10;    suspend fun getLeaderboardData(): List&lt;UserProfile&gt; {&#10;        return try {&#10;            usersCollection&#10;                .orderBy(&quot;totalScore&quot;, Query.Direction.DESCENDING)&#10;                .limit(100) // Limit to top 100 to avoid pulling too much data&#10;                .get()&#10;                .await()&#10;                .toObjects(UserProfile::class.java)&#10;        } catch (e: Exception) {&#10;            // Return an empty list or throw the exception to be handled by the presenter&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    // --- Quiz Packages ---&#10;    fun getPaketList(): Flow&lt;List&lt;QuizPackage&gt;&gt; {&#10;        return quizPackageDao.getAllQuizPackages()&#10;    }&#10;&#10;    suspend fun refreshPaketList() {&#10;        try {&#10;            android.util.Log.d(&quot;QuizRepository&quot;, &quot;Starting refreshPaketList from Firebase&quot;)&#10;            val result = paketCollection.get().await()&#10;            android.util.Log.d(&quot;QuizRepository&quot;, &quot;Firebase returned ${result.documents.size} documents&quot;)&#10;            &#10;            // Log setiap dokumen untuk debugging&#10;            result.documents.forEach { doc -&gt;&#10;                android.util.Log.d(&quot;QuizRepository&quot;, &quot;Document ID: ${doc.id}, Data: ${doc.data}&quot;)&#10;            }&#10;            &#10;            val firebasePaketList = result.documents.mapNotNull { document -&gt;&#10;                val paket = document.toObject(Paket::class.java)&#10;                if (paket != null) {&#10;                    paket.id = document.id&#10;                    android.util.Log.d(&quot;QuizRepository&quot;, &quot;Parsed Paket: namaPaket=${paket.namaPaket}, isSecret=${paket.isSecret}&quot;)&#10;                } else {&#10;                    android.util.Log.w(&quot;QuizRepository&quot;, &quot;Failed to parse document ${document.id}&quot;)&#10;                }&#10;                paket&#10;            }&#10;            android.util.Log.d(&quot;QuizRepository&quot;, &quot;Parsed ${firebasePaketList.size} Paket objects&quot;)&#10;&#10;            val packagesToUpsert = mutableListOf&lt;QuizPackage&gt;()&#10;&#10;            for (paket in firebasePaketList.filter { !it.isSecret }) {&#10;                val existingPackage = quizPackageDao.getQuizPackageByName(paket.namaPaket)&#10;&#10;                val mergedPackage = QuizPackage(&#10;                    name = paket.namaPaket,&#10;                    description = &quot;&quot;,&#10;                    score = existingPackage?.score ?: 0,&#10;                    isCompleted = existingPackage?.isCompleted ?: false&#10;                )&#10;                packagesToUpsert.add(mergedPackage)&#10;                android.util.Log.d(&quot;QuizRepository&quot;, &quot;Added package to upsert: ${paket.namaPaket}&quot;)&#10;            }&#10;&#10;            android.util.Log.d(&quot;QuizRepository&quot;, &quot;Inserting ${packagesToUpsert.size} packages to Room&quot;)&#10;            quizPackageDao.insertAll(*packagesToUpsert.toTypedArray())&#10;            android.util.Log.d(&quot;QuizRepository&quot;, &quot;Successfully inserted packages to Room&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;QuizRepository&quot;, &quot;Error in refreshPaketList&quot;, e)&#10;            throw e&#10;        }&#10;    }&#10;&#10;    // --- Questions ---&#10;    suspend fun getSoalList(paketId: String, forceRefresh: Boolean = false): List&lt;Question&gt; {&#10;        var localQuestions = questionDao.getQuestionsForQuiz(paketId)&#10;        if (localQuestions.isNotEmpty() &amp;&amp; !forceRefresh) {&#10;            return localQuestions&#10;        }&#10;&#10;        // If local is empty or force refresh, try fetching from Firebase&#10;        val firebaseSoalList = soalCollection.whereEqualTo(&quot;paketId&quot;, paketId).get().await()&#10;            .documents.mapNotNull { document -&gt;&#10;                document.toObject(Soal::class.java)?.apply { id = document.id }&#10;            }&#10;&#10;        val questionsToCache = firebaseSoalList.map { soal -&gt;&#10;            Question(&#10;                id = soal.id,&#10;                quizPackageName = paketId,&#10;                questionText = soal.soal,&#10;                questionImageUrl = soal.gambarSoal,&#10;                choices = soal.pilihan.map { Pilihan(it.id, it.teks, it.gambar) },&#10;                correctAnswerId = soal.jawabanBenar&#10;            )&#10;        }&#10;&#10;        if (questionsToCache.isNotEmpty()) {&#10;            questionDao.insertAll(questionsToCache)&#10;        }&#10;&#10;        return questionsToCache&#10;    }&#10;&#10;    // --- Score Updates ---&#10;    suspend fun updateQuizScore(quizName: String, newScore: Int) {&#10;        // Update Local Score (Room)&#10;        val existingPackage = quizPackageDao.getQuizPackageByName(quizName)&#10;        if (existingPackage != null) {&#10;            if (newScore &gt; existingPackage.score) {&#10;                val updatedPackage = existingPackage.copy(score = newScore, isCompleted = true)&#10;                quizPackageDao.updateQuizPackage(updatedPackage)&#10;            } else {&#10;                if (!existingPackage.isCompleted) {&#10;                    val updatedPackage = existingPackage.copy(isCompleted = true)&#10;                    quizPackageDao.updateQuizPackage(updatedPackage)&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Update Remote Score (Firestore)&#10;        updateUserScoresInFirestore(quizName, newScore)&#10;    }&#10;&#10;    private suspend fun updateUserScoresInFirestore(quizName: String, newScore: Int) {&#10;        val currentUser = auth.currentUser ?: return&#10;        val userId = currentUser.uid&#10;        val userDocRef = usersCollection.document(userId)&#10;&#10;        try {&#10;            db.runTransaction {&#10;                transaction -&gt;&#10;                val snapshot = transaction.get(userDocRef)&#10;&#10;                if (snapshot.exists()) {&#10;                    // Document exists, so UPDATE it&#10;                    val raw = snapshot.get(&quot;quizScores&quot;) as? Map&lt;*, *&gt; ?: emptyMap&lt;Any, Any?&gt;()&#10;                    val oldQuizScores: Map&lt;String, Long&gt; = raw.entries.associate { (k, v) -&gt;&#10;                        val key = k.toString()&#10;                        val value = when (v) {&#10;                            is Number -&gt; v.toLong()&#10;                            is String -&gt; v.toLongOrNull() ?: 0L&#10;                            else -&gt; 0L&#10;                        }&#10;                        key to value&#10;                    }&#10;                    val oldTotalScore = snapshot.getLong(&quot;totalScore&quot;) ?: 0L&#10;                    val oldScoreForThisQuiz = oldQuizScores[quizName] ?: 0L&#10;&#10;                    if (newScore &gt; oldScoreForThisQuiz) {&#10;                        val scoreDifference = newScore - oldScoreForThisQuiz&#10;                        val newTotalScore = oldTotalScore + scoreDifference&#10;                        transaction.update(userDocRef, &quot;quizScores.$quizName&quot;, newScore.toLong())&#10;                        transaction.update(userDocRef, &quot;totalScore&quot;, newTotalScore)&#10;                    }&#10;                } else {&#10;                    // Document does not exist, so CREATE it&#10;                    val newUserProfile = UserProfile(&#10;                        uid = userId,&#10;                        email = currentUser.email ?: &quot;&quot;,&#10;                        username = currentUser.displayName ?: &quot;&quot;,&#10;                        quizScores = mapOf(quizName to newScore.toLong()),&#10;                        totalScore = newScore.toLong(),&#10;                        unlockedQuizzes = emptyMap() // Default for new user&#10;                    )&#10;                    transaction.set(userDocRef, newUserProfile)&#10;                }&#10;                null&#10;            }.await()&#10;        } catch (e: Exception) {&#10;            // For now, we let it fail silently so it doesn't crash the app&#10;            android.util.Log.e(&quot;QuizRepository&quot;, &quot;updateUserScoresInFirestore failed&quot;, e)&#10;        }&#10;    }&#10;&#10;    // --- New: User score sync utilities ---&#10;    /**&#10;     * Fetch quizScores map for a user from Firestore (returns empty map on failure)&#10;     */&#10;    suspend fun getUserQuizScores(uid: String): Map&lt;String, Long&gt; {&#10;        return try {&#10;            val doc = usersCollection.document(uid).get().await()&#10;            if (doc.exists()) {&#10;                val raw = doc.get(&quot;quizScores&quot;) as? Map&lt;*, *&gt; ?: emptyMap&lt;Any, Any?&gt;()&#10;                raw.entries.associate { (k, v) -&gt;&#10;                    val key = k.toString()&#10;                    val value = when (v) {&#10;                        is Number -&gt; v.toLong()&#10;                        is String -&gt; v.toLongOrNull() ?: 0L&#10;                        else -&gt; 0L&#10;                    }&#10;                    key to value&#10;                }&#10;            } else {&#10;                emptyMap()&#10;            }&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;QuizRepository&quot;, &quot;Failed to fetch user quizScores&quot;, e)&#10;            emptyMap()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clear all local quiz package scores in Room (used when offline session not associated with account)&#10;     */&#10;    suspend fun clearLocalScores() {&#10;        try {&#10;            quizPackageDao.clearQuizPackages()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;QuizRepository&quot;, &quot;Failed to clear local scores&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sync scores between Firestore and Room for given user uid.&#10;     * Strategy: for each quiz in Firestore or Room, keep the higher score in both places.&#10;     */&#10;    suspend fun syncScoresForUser(uid: String) {&#10;        try {&#10;            val remoteScores = getUserQuizScores(uid).toMutableMap()&#10;&#10;            // pull all local packages&#10;            val localPackages = quizPackageDao.getAllQuizPackagesOnce()&#10;&#10;            // Merge keys&#10;            val allKeys = (remoteScores.keys + localPackages.map { it.name }).toSet()&#10;&#10;            var anyRemoteUpdated = false&#10;             for (quizName in allKeys) {&#10;                 val localPkg = localPackages.find { it.name == quizName }&#10;                 val localScore = localPkg?.score ?: 0&#10;                 val remoteScore = (remoteScores[quizName] ?: 0L).toInt()&#10;&#10;                 val winnerScore = maxOf(localScore, remoteScore)&#10;&#10;                 // update local&#10;                 if (localPkg != null) {&#10;                     val updatedPkg = localPkg.copy(score = winnerScore, isCompleted = winnerScore &gt; 0)&#10;                     quizPackageDao.updateQuizPackage(updatedPkg)&#10;                 } else {&#10;                     // insert new package to local&#10;                     val newPkg = QuizPackage(name = quizName, description = &quot;&quot;, score = winnerScore, isCompleted = winnerScore &gt; 0)&#10;                     quizPackageDao.insertAll(newPkg)&#10;                 }&#10;&#10;                 // update remote if needed&#10;                 val remoteScoreLong = remoteScores[quizName] ?: 0L&#10;                 if (winnerScore.toLong() &gt; remoteScoreLong) {&#10;                     // write to firestore user document&#10;                     try {&#10;                         val userRef = usersCollection.document(uid)&#10;                         userRef.update(&quot;quizScores.$quizName&quot;, winnerScore.toLong()).await()&#10;                         // adjust totalScore as naive sum difference (for safety, we can recalc totalScore server-side)&#10;                         val doc = userRef.get().await()&#10;                         val oldTotal = doc.getLong(&quot;totalScore&quot;) ?: 0L&#10;                         val oldForQuiz = remoteScoreLong&#10;                         val newTotal = oldTotal + (winnerScore.toLong() - oldForQuiz)&#10;                         userRef.update(&quot;totalScore&quot;, newTotal).await()&#10;                         // notify leaderboard listeners that remote data changed&#10;                         try { com.example.misi_budaya.util.AppEvents.emitLeaderboardRefresh() } catch (_: Exception) {}&#10;                        anyRemoteUpdated = true&#10;                     } catch (e: Exception) {&#10;                         android.util.Log.e(&quot;QuizRepository&quot;, &quot;Failed to update remote score for $quizName&quot;, e)&#10;                     }&#10;                 }&#10;             }&#10;&#10;            // If any remote updates occurred, emit a final refresh event to be safe&#10;            if (anyRemoteUpdated) {&#10;                try { com.example.misi_budaya.util.AppEvents.emitLeaderboardRefresh() } catch (_: Exception) {}&#10;            }&#10;         } catch (e: Exception) {&#10;             android.util.Log.e(&quot;QuizRepository&quot;, &quot;Error in syncScoresForUser&quot;, e)&#10;         }&#10;     }&#10;&#10;    suspend fun getPaketByName(namaPaket: String): Paket? {&#10;        return try {&#10;            val query = paketCollection.whereEqualTo(&quot;NamaPaket&quot;, namaPaket).limit(1).get().await()&#10;            val doc = query.documents.firstOrNull()&#10;            doc?.toObject(Paket::class.java)?.apply { id = doc.id }&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;QuizRepository&quot;, &quot;Failed to fetch Paket by name&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    suspend fun downloadAllQuestionsForAllPackages() {&#10;        try {&#10;            android.util.Log.d(&quot;QuizRepository&quot;, &quot;Starting download all questions for all packages&quot;)&#10;&#10;            // Get all packages from local DB&#10;            val allPackages = quizPackageDao.getAllQuizPackagesOnce()&#10;&#10;            for (paket in allPackages) {&#10;                try {&#10;                    // Get questions from Firebase for this package&#10;                    val firebaseSoalList = soalCollection.whereEqualTo(&quot;paketId&quot;, paket.name).get().await()&#10;                        .documents.mapNotNull { document -&gt;&#10;                            document.toObject(Soal::class.java)?.apply { id = document.id }&#10;                        }&#10;&#10;                    if (firebaseSoalList.isNotEmpty()) {&#10;                        val questionsToCache = firebaseSoalList.map { soal -&gt;&#10;                            Question(&#10;                                id = soal.id,&#10;                                quizPackageName = paket.name,&#10;                                questionText = soal.soal,&#10;                                questionImageUrl = soal.gambarSoal,&#10;                                choices = soal.pilihan.map { Pilihan(it.id, it.teks, it.gambar) },&#10;                                correctAnswerId = soal.jawabanBenar&#10;                            )&#10;                        }&#10;&#10;                        android.util.Log.d(&quot;QuizRepository&quot;, &quot;Inserting ${questionsToCache.size} questions for package ${paket.name}&quot;)&#10;                        // insertAll uses OnConflictStrategy.REPLACE, so old questions will be replaced&#10;                        questionDao.insertAll(questionsToCache)&#10;                        android.util.Log.d(&quot;QuizRepository&quot;, &quot;Successfully inserted questions for ${paket.name}&quot;)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    android.util.Log.e(&quot;QuizRepository&quot;, &quot;Failed to download questions for ${paket.name}&quot;, e)&#10;                    // Continue downloading for other packages even if one fails&#10;                }&#10;            }&#10;&#10;            android.util.Log.d(&quot;QuizRepository&quot;, &quot;Successfully downloaded all questions&quot;)&#10;            // notify UI that questions are available locally&#10;            try {&#10;                com.example.misi_budaya.util.AppEvents.emitQuestionsDownloaded()&#10;            } catch (_: Exception) {}&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;QuizRepository&quot;, &quot;Error in downloadAllQuestionsForAllPackages&quot;, e)&#10;            throw e&#10;        }&#10;    }&#10;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>